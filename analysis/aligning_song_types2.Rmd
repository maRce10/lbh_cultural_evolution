---
title: <center><font size="6"><b>Aligning song types</b></font></center>
subtitle: <center><font size="4"><b>Long-billed hermit song cultural evolution</b></font></center>
author: <center><font size="4"><a href="http://marceloarayasalas.weebly.com/">Marcelo Araya-Salas, PhD</a></font></center>
date: <center>`r format(Sys.Date(), "%d-%m-%Y")`</center>
output:
  html_document:
    code_folding: hide
    toc: yes
    toc_depth: 3
    toc_float:
      collapsed: no
      smooth_scroll: no
fontsize: 12pt 
editor_options: 
  chunk_output_type: console
---

```{r clean session, eval = TRUE, echo=FALSE, message=FALSE, warning = FALSE}

#clean session
rm(list = ls())

# unload all non-based packages
out <- sapply(paste('package:', names(sessionInfo()$otherPkgs), sep = ""), function(x) try(detach(x, unload = FALSE, character.only = TRUE), silent = T))

## vector with package names
x <- c( "pbapply", "parallel", "ggplot2", "ape", "seqinr", "ips","gtools", "seqmagick", "ggmsa"
        )

aa <- lapply(x, function(y) {
  
  # check if installed, if not then install 
  if (!y %in% installed.packages()[,"Package"]) 
    install.packages(y) 

  # load package
  try(require(y, character.only = T), silent = T)
})
```

```{r functions and parameters, eval = TRUE, echo = TRUE}

#functions and parameters
knitr::opts_knit$set(root.dir = normalizePath(".."))

knitr::opts_chunk$set(dpi = 58, fig.width = 12) 

# ggplot2 theme
theme_set(theme_classic(base_size = 20))

split_seqs <- function(x) {
 
  # from start to end
  y <-  sapply(1:20, function(y) 
     if (y == 1)
    ifelse(substr(x, start = y + 1, stop = y + 1) == substr(x, start = y, stop = y), 0 , 1) else
          ifelse(substr(x, start = y - 1, stop = y - 1) == substr(x, start = y, stop = y), 0 , 1)
    )

  x2 <- strsplit(x, "")[[1]]
  
  w1 <- which(y == 1)
  
  # to add single elements at the end
    w1 <- c(w1, 21)
  if (w1[1] == 1 & w1[2] == 2) w1 <- w1[2:length(w1)]
    
  sgmts <- lapply(1:length(w1), function(w){
    if (w1[w] == w1[1]) paste(x2[1:(w1[w] - 1)], collapse = "")  else
  paste(x2[w1[w - 1]:(w1[w] - 1)], collapse = "")  
  })

  return(sgmts)
}

write_lek_fas <- function(x){
  
 lk <- unlist(strsplit(x[seq(1, length(x), by = 2)], split = "_"))[seq(1, length(x), by = 2)]
  
 lk <- gsub(">", "", paste0(lk, "_"))
 
 out <- sapply(unique(lk), USE.NAMES = FALSE, function(y){
   
   
   wch.lk <- grep(pattern = y, x = x)
   
   fl.nms <-tempfile(tmpdir = getwd(), fileext =  paste0("song.seq_",y, "SongsSeq.fa"))
   
   writeLines(x[min(wch.lk):(max(wch.lk)+ 1)], con = fl.nms)
   
   return(basename(fl.nms))
 })

 return(out)  
}

# get leks with more than 5 song types
leks <- c("BR1", "CCE", "CCL", "HC1", "HC2", "LOC", "SAT", "SJA", "SUR", "TR1", "TR2")
```

```{r create fastas for each lek mafft, eval = FALSE,  echo = TRUE}

# create fastas for each lek

###----Alignment of phenotypic sequence data: CSV to fasta format----------------------

dat <- read.csv("./data/raw/segments_by_song_type.csv", stringsAsFactors = FALSE)
yrs <- read.csv("./data/raw/year_range_by_song_type.csv", stringsAsFactors = FALSE)

#Are id's unique?
length(dat$song.type) == length(unique(dat$song.type)) #OK

# seq as a single column
dat$seqs <- sapply(1:nrow(dat), function(i)  paste(dat[i,3:22], collapse = "")
)

# one for each songtype year
dat.yr <- yrs

dat.yr$song.type.year <- paste(dat.yr$song.type, dat.yr$year, sep = "-")

dat.yr <- dat.yr[dat.yr$lek %in% leks, ]


dat.yr <- merge(dat.yr, dat[, c("song.type", "seqs")], by = "song.type")


# only 1 year per song type and using before 2008
dat.all.old <- dat.yr[order(dat.yr$song.type, dat.yr$year), ]

# only 1 year per song type and using before 2008
dat.early.old <- dat.all.old[!duplicated(dat.all.old$song.type), ]

# only 1 year per song type and exlcuding before 2008
dat.all.new <- dat.all.old[dat.all.old$year > 2007, ]

# only 1 year per song type and using before 2008
dat.early.new <- dat.early.old[dat.early.old$year > 2008, ]

# rest of song type years (without earliest)
dat.rest.old <- dat.all.old[!dat.all.old$song.type.year %in% dat.early.old$song.type.year,]

dat.rest.new <- dat.all.new[!dat.all.new$song.type.year %in% dat.early.new$song.type.year,]


# by lek all song types
for(i in leks){
  
# all old
write.fasta(sequences = as.list(dat.rest.old$seqs[dat.rest.old$lek == i]), names = dat.rest.old$song.type.year[dat.rest.old$lek == i], file.out = paste0("./data/processed/song_sequences/song_seqs_rest_old_", i, ".fa"), open = "w", nbchar = 60, as.string = FALSE)

# early old
write.fasta(sequences = as.list(dat.early.old$seqs[dat.early.old$lek == i]), names = dat.early.old$song.type.year[dat.early.old$lek == i], file.out = paste0("./data/processed/song_sequences/song_seqs_early_old_", i, ".fa"), open = "w", nbchar = 60, as.string = FALSE)

# all new
write.fasta(sequences = as.list(dat.rest.new$seqs[dat.rest.new$lek == i]), names = dat.rest.new$song.type.year[dat.rest.new$lek == i], file.out = paste0("./data/processed/song_sequences/song_seqs_rest_new_", i, ".fa"), open = "w", nbchar = 60, as.string = FALSE)

# early new
write.fasta(sequences = as.list(dat.early.new$seqs[dat.early.new$lek == i]), names = dat.early.new$song.type.year[dat.early.new$lek == i], file.out = paste0("./data/processed/song_sequences/song_seqs_early_new_", i, ".fa"), open = "w", nbchar = 60, as.string = FALSE)
  }

```

```{r test aligning, eval = FALSE,  echo = TRUE}
# alignments real songs

# add using or not song types before 2008
use.old.fossils <- c("old", "new")

# type of costs 
type <- c("optimal", "all.equal")

grd.costs <- expand.grid(use.old.fossils = use.old.fossils, type = type)

unq.sgmts <- c("d", "f", "m", "p", "s", "u")

asc.val <- c("0x73", "0x75", "0x70", "0x6D", "0x66", "0x64")


cost <- matrix(c(0.5, 1.25, 2, 0.5, 1.25, 2, # optimal
               rep(1, 6)), # equal costs
               nrow = 4, byrow = TRUE)

cost.mat <- data.frame(cost, stringsAsFactors = FALSE)

names(cost.mat)[1:3] <- c("different.category", "same.category", "same.segment")

cost.mat <- data.frame(cost.mat, grd.costs, stringsAsFactors = FALSE)


# grid cost values
grd.sgm <- expand.grid(sgmt1 = unq.sgmts, sgmt2 = unq.sgmts)

grd.sgm$type <- "different.category"

trlls <- c("f", "m", "s")
tones <- c("d", "p", "u")
grd.sgm$type[grd.sgm$sgmt1 %in% trlls & grd.sgm$sgmt2 %in% trlls] <-  "same.category"
grd.sgm$type[grd.sgm$sgmt1 %in% tones & grd.sgm$sgmt2 %in% tones] <- "same.category"
grd.sgm$type[grd.sgm$sgmt1 == grd.sgm$sgmt2] <- "same.segment"

# create combs
cost.grds <- pblapply(1:nrow(cost.mat), cl = 3, function(x){
  
  grd.sgm$cost <- NA
  grd.sgm$cost[grd.sgm$type == "different.category"] <- cost.mat$different.category[x]
  grd.sgm$cost[grd.sgm$type == "same.category"] <- cost.mat$same.category[x]
  grd.sgm$cost[grd.sgm$type == "same.segment"] <- cost.mat$same.segment[x]

  grd.sgm$pair <- paste(grd.sgm$sgmt1, "x", grd.sgm$sgmt2)

  grd.sgm$asc1 <- grd.sgm$sgmt1
  grd.sgm$asc2 <- grd.sgm$sgmt2
  
  for(i in 1:length(unq.sgmts)){
    grd.sgm$asc1 <- gsub(unq.sgmts[i], asc.val[i], grd.sgm$asc1)
    grd.sgm$asc2 <- gsub(unq.sgmts[i], asc.val[i], grd.sgm$asc2)
  }

  grd.sgm$cost.type <- cost.mat$type[x]
  grd.sgm$cost.vals <- cost.mat$cost.vals[x]
  
  grd.sgm$use.old.fossils <- cost.mat$use.old.fossils[x]
  
  return(grd.sgm)
})

length(cost.grds)

# get leks with more than 5 song types
# leks <- names(table(sgmnts$lek))[table(sgmnts$lek)> 5]


pboptions(type = "timer")

# exclude all  equal
# cost.grds <- cost.grds[1]


  Y <- cost.grds[[3]]
  w <- apply(Y[, c("asc1", "asc2", "cost")], 1, paste,  collapse = " ")
  
  writeLines(w, con = paste0("./data/processed/mafft_alignments/",Y$cost.type[1],"_cost_matrix.txt"))
  
  i <- "CCL"
    
    cll <- paste0("mafft --localpair --maxiterate 50000 --textmatrix ./data/processed/mafft_alignments/",Y$cost.type[1] ,"_cost_matrix.txt ./data/processed/song_sequences/song_seqs_early_", Y$use.old.fossils[1], "_", i,".fa > ./data/processed/mafft_alignments/", i, "_", Y$cost.type[1], "_early_",  Y$use.old.fossils[1],  "_alignment.fa 2> ./data/processed/mafft_alignments/early_", Y$use.old.fossils[1], "_", i,"_", Y$cost.type[1], "_mafft_output.txt")
    
    # system(cll)
    
```

```{r alignments real songs mafft, eval = FALSE,  echo = TRUE}
# alignments real songs

# add using or not song types before 2008
use.old.fossils <- c("old", "new")

# type of costs 
type <- c("optimal", "all.equal")

grd.costs <- expand.grid(use.old.fossils = use.old.fossils, type = type)

unq.sgmts <- c("d", "f", "m", "p", "s", "u")

asc.val <- c("0x73", "0x75", "0x70", "0x6D", "0x66", "0x64")


cost <- matrix(c(0.5, 1.25, 2, 0.5, 1.25, 2, # optimal
               rep(c(1, 1, 1.5), 2)), # equal costs
               nrow = 4, byrow = TRUE)

cost.mat <- data.frame(cost, stringsAsFactors = FALSE)

names(cost.mat)[1:3] <- c("different.category", "same.category", "same.segment")

cost.mat <- data.frame(cost.mat, grd.costs, stringsAsFactors = FALSE)


# grid cost values
grd.sgm <- expand.grid(sgmt1 = unq.sgmts, sgmt2 = unq.sgmts)

grd.sgm$type <- "different.category"

trlls <- c("f", "m", "s")
tones <- c("d", "p", "u")
grd.sgm$type[grd.sgm$sgmt1 %in% trlls & grd.sgm$sgmt2 %in% trlls] <-  "same.category"
grd.sgm$type[grd.sgm$sgmt1 %in% tones & grd.sgm$sgmt2 %in% tones] <- "same.category"
grd.sgm$type[grd.sgm$sgmt1 == grd.sgm$sgmt2] <- "same.segment"

# create combs
cost.grds <- pblapply(1:nrow(cost.mat), cl = 3, function(x){
  
  grd.sgm$cost <- NA
  grd.sgm$cost[grd.sgm$type == "different.category"] <- cost.mat$different.category[x]
  grd.sgm$cost[grd.sgm$type == "same.category"] <- cost.mat$same.category[x]
  grd.sgm$cost[grd.sgm$type == "same.segment"] <- cost.mat$same.segment[x]

  grd.sgm$pair <- paste(grd.sgm$sgmt1, "x", grd.sgm$sgmt2)

  grd.sgm$asc1 <- grd.sgm$sgmt1
  grd.sgm$asc2 <- grd.sgm$sgmt2
  
  for(i in 1:length(unq.sgmts)){
    grd.sgm$asc1 <- gsub(unq.sgmts[i], asc.val[i], grd.sgm$asc1)
    grd.sgm$asc2 <- gsub(unq.sgmts[i], asc.val[i], grd.sgm$asc2)
  }

  grd.sgm$cost.type <- cost.mat$type[x]
  grd.sgm$cost.vals <- cost.mat$cost.vals[x]
  
  grd.sgm$use.old.fossils <- cost.mat$use.old.fossils[x]
  
  return(grd.sgm)
})

length(cost.grds)

# get leks with more than 5 song types
# leks <- names(table(sgmnts$lek))[table(sgmnts$lek)> 5]


pboptions(type = "timer")

yrs <- read.csv("./data/raw/year_range_by_song_type.csv", stringsAsFactors = FALSE)

# exclude all  equal
# cost.grds <- cost.grds[1]

out <- pblapply(1:length(cost.grds), cl = parallel::detectCores() - 1, function(y){
  
  Y <- cost.grds[[y]]
  w <- apply(Y[, c("asc1", "asc2", "cost")], 1, paste,  collapse = " ")
  
  writeLines(w, con = paste0("./data/processed/mafft_alignments/",Y$cost.type[1],"_cost_matrix.txt"))
  
  out <- lapply(leks, function(i){
    
    # don't do those with no data before 2008
    if (min(yrs$year[yrs$lek == i]) > 2000 & Y$use.old.fossils[1] == "old")
      return(NULL) else
      {      
          cll <- paste0("mafft --localpair --maxiterate 50000 --textmatrix ./data/processed/mafft_alignments/",Y$cost.type[1] ,"_cost_matrix.txt ./data/processed/song_sequences/song_seqs_early_", Y$use.old.fossils[1], "_", i,".fa > ./data/processed/mafft_alignments/", i, "_", Y$cost.type[1], "_early_",  Y$use.old.fossils[1],  "_alignment.fa 2> ./data/processed/mafft_alignments/early_", Y$use.old.fossils[1], "_", i,"_", Y$cost.type[1], "_mafft_output.txt")
  
      system(cll)
    
    alg <- readLines(paste0("./data/processed/mafft_alignments/",i,"_", Y$cost.type[1], "_early_",  Y$use.old.fossils[1], "_alignment.fa"))[2]
    gaps <- nchar(alg) - 20
    
    convg <- ifelse(any(grepl("Converged", readLines(paste0("./data/processed/mafft_alignments/early_", Y$use.old.fossils[1], "_", i ,"_", Y$cost.type[1],"_mafft_output.txt")))), "Y", "N")
    
    df2 <- data.frame(lek = i, gaps, convg, cost.type = Y$cost.type[1], use.old.fossils = Y$use.old.fossils[1])
    
    return(df2)
    } 
  })
  
  out <- out[!sapply(out, is.null)]
  
  res <- do.call(rbind, out)
  
  return(res)
})

res <- do.call(rbind, out)

write.csv(res, "./output/aligment_gaps_and_convergence_results.csv")

```

```{r add new sequences mafft, eval = FALSE,   echo = TRUE}

#add new sequences only for optimal so far

alg <- list.files(path = "./data/processed/mafft_alignments", pattern = "alignment.fa$", full.names = TRUE)

# and new
rest.seqs <- list.files(path = "./data/processed/song_sequences", pattern = "rest", full.names = TRUE)


out <- lapply(leks, function(x){
  
  # get alignments for x lek
  lk.alg <- grep(x, alg, value = TRUE)

  for(w  in lk.alg){
    cost_mat <- ifelse(grepl("optimal", w), "optimal", "all.equal")
    use_old_fossils <- ifelse(grepl("old", w), "old", "new")
  
    cll <- paste0("mafft --anysymbol --keeplength --add ", grep(paste0("new_", x), rest.seqs, value = TRUE)," --reorder ", file.path("./data/processed/mafft_alignments", paste(x, cost_mat, "early", use_old_fossils ,"alignment.fa", sep = "_")), " > ",     file.path("./data/processed/mafft_alignments", paste(x, cost_mat, "all", use_old_fossils ,"alignment.fa", sep = "_")))

  
    system(cll)
    }
  })

```

```{r create fastas for each lek prank, eval = FALSE,  echo = TRUE}

# create fastas for each lek

###----Alignment of phenotypic sequence data: CSV to fasta format----------------------

dat <- read.csv("./data/raw/segments_by_song_type.csv", stringsAsFactors = FALSE)
yrs <- read.csv("./data/raw/year_range_by_song_type.csv", stringsAsFactors = FALSE)

#Are id's unique?
length(dat$song.type) == length(unique(dat$song.type)) #OK

# seq as a single column
dat$seqs <- sapply(1:nrow(dat), function(i)  paste(dat[i,3:22], collapse = "")
)

# replace song segments with bases
dat$seqs <- gsub(pattern = "f", replacement = "C", x = dat$seqs) # trill to pyrimidine
  dat$seqs <- gsub(pattern = "s", replacement = "T", x = dat$seqs) # trill to pyrimidine
  dat$seqs <- gsub(pattern = "m", replacement = "Y", x = dat$seqs) # medium trill treated as ambiguous between fast and slow
  dat$seqs <- gsub(pattern = "u", replacement = "A", x = dat$seqs) # tone to purine
  dat$seqs <- gsub(pattern = "d", replacement = "G", x = dat$seqs) # tone to purine
  dat$seqs <- gsub(pattern = "p", replacement = "R", x = dat$seqs)


# one for each songtype year
dat.yr <- yrs

dat.yr$song.type.year <- paste(dat.yr$song.type, dat.yr$year, sep = "-")

dat.yr <- dat.yr[dat.yr$lek %in% leks, ]


dat.yr <- merge(dat.yr, dat[, c("song.type", "seqs")], by = "song.type")


# only 1 year per song type and using before 2008
dat.all.old <- dat.yr[order(dat.yr$song.type, dat.yr$year), ]

# only 1 year per song type and using before 2008
dat.early.old <- dat.all.old[!duplicated(dat.all.old$song.type), ]

# only 1 year per song type and exlcuding before 2008
dat.all.new <- dat.all.old[dat.all.old$year > 2000, ]

# only 1 year per song type and using before 2008
dat.early.new <- dat.early.old[dat.early.old$year > 2000, ]

# rest of song type years (without earliest)
dat.rest.old <- dat.all.old[!dat.all.old$song.type.year %in% dat.early.old$song.type.year,]

dat.rest.new <- dat.all.new[!dat.all.new$song.type.year %in% dat.early.new$song.type.year,]


# by lek all song types
for(i in leks){
  
# all old
write.fasta(sequences = as.list(dat.rest.old$seqs[dat.rest.old$lek == i]), names = dat.rest.old$song.type.year[dat.rest.old$lek == i], file.out = paste0("./data/processed/song_sequences/song_seqs_rest_old_", i, "_prank.fa"), open = "w", nbchar = 60, as.string = FALSE)

# early old
write.fasta(sequences = as.list(dat.early.old$seqs[dat.early.old$lek == i]), names = dat.early.old$song.type.year[dat.early.old$lek == i], file.out = paste0("./data/processed/song_sequences/song_seqs_early_old_", i, "_prank.fa"), open = "w", nbchar = 60, as.string = FALSE)

# all new
write.fasta(sequences = as.list(dat.rest.new$seqs[dat.rest.new$lek == i]), names = dat.rest.new$song.type.year[dat.rest.new$lek == i], file.out = paste0("./data/processed/song_sequences/song_seqs_rest_new_", i, "_prank.fa"), open = "w", nbchar = 60, as.string = FALSE)

# early new
write.fasta(sequences = as.list(dat.early.new$seqs[dat.early.new$lek == i]), names = dat.early.new$song.type.year[dat.early.new$lek == i], file.out = paste0("./data/processed/song_sequences/song_seqs_early_new_", i, "_prank.fa"), open = "w", nbchar = 60, as.string = FALSE)
  }

```


```{r alignments real songs prank, eval = FALSE,  echo = TRUE}

prank_seqs <- list.files(path = "./data/processed/song_sequences", pattern = "prank")

# get only early ones
prank_seqs_early <- grep("early", prank_seqs, value = TRUE) 

# get rest
prank_seqs_rest <- grep("rest", prank_seqs, value = TRUE) 

out <- pblapply(prank_seqs_early, function(x) {

  lek <- sapply(strsplit(x, "_", fixed = TRUE), "[[", 5)
  all.fossils <- sapply(strsplit(x, "_", fixed = TRUE), "[[", 4)
  old.fossils <- sapply(strsplit(x, "_", fixed = TRUE), "[[", 3)
  
  cll <- paste0("prank -d=./data/processed/song_sequences/", x, " -o=./data/processed/mafft_alignments/", lek, "_prank_", old.fossils, "_", all.fossils,"_alignment.fa -iterate=100 -kappa=2")

  system(cll)
  })



# remove best.fas suffix
prank_algn <- list.files(path = "./data/processed/mafft_alignments", pattern = "best.fas", full.name = TRUE)

file.rename(from = prank_algn, to = gsub(".best.fas$", "", prank_algn))


```

```{r add new sequences prank, eval = FALSE,   echo = TRUE}

#add new sequences only for optimal so far

alg <- list.files(path = "./data/processed/mafft_alignments", pattern = "prank", full.names = TRUE)

# and new
rest.seqs <- list.files(path = "./data/processed/song_sequences", pattern = "rest", full.names = TRUE)

rest.seqs <- grep("prank", rest.seqs, value = TRUE)

out <- lapply(leks, function(x){
  
  # get alignments for x lek
  lk.alg <- grep(x, alg, value = TRUE)

  for(w  in lk.alg){
    cost_mat <- "prank"
    use_old_fossils <- ifelse(grepl("old", w), "old", "new")
  
    cll <- paste0("mafft --anysymbol --keeplength --add ", grep(paste0("new_", x), rest.seqs, value = TRUE)," --reorder ", file.path("./data/processed/mafft_alignments", paste(x, cost_mat, "early", use_old_fossils ,"alignment.fa", sep = "_")), " > ",     file.path("./data/processed/mafft_alignments", paste(x, cost_mat, "all", use_old_fossils ,"alignment.fa", sep = "_")))

    system(cll)
    }
  })

```

# Plot alignments

optimal (1 sample per song type): diff type = 0.5, same category = 1.25, same segment = 2

- "full" contains species as song type-year, added later with MAFFT option --keeplength

```{r plot alignments, eval = TRUE,  echo = TRUE, out.width = "100%", out.height = "100%", warning= FALSE, message=FALSE}

#plot alignments
seqs <- list.files(path = "./data/processed/mafft_alignments", pattern = "\\.fa$", full.names = TRUE)

out <- lapply(seqs, function(i){
  ggmsa(i, color = "Chemistry_AA") + ggtitle(gsub("_|\\.fa", " ", basename(i)))
  })

out

```

```{r save nexus files, eval = FALSE,  echo = TRUE}

### Convert fasta alignment to nexus
# read all alignments
all.algs <- list.files(pattern = ".fa$", path = "./data/processed/mafft_alignments/")

# loop over alignments
for (j in all.algs){

  lek <- substring(j, 0, 3) 
  cost_mat <- if(grepl("optimal", j)) "optimal" 
  cost_mat <- if(grepl("all.equal", j)) "all.equal" 
  cost_mat <- if(grepl("prank", j)) "prank" 
  
  use_old_fossils <- ifelse(grepl("old", j), "old", "new")
  
  
  # paste together call
  cll <- paste0(" perl ./source/convertfasta2nex.pl ./data/processed/mafft_alignments/", j, " > ",  "./data/processed/nexus/", gsub("\\.fa$", ".nex", j))

 # call perl
 system(cll)  
}

# fix nexus header 
Nex.file <-list.files(pattern = ".nex$", path = "./data/processed/nexus/", full.names = TRUE)

 
for(i in Nex.file){  
   align <- readLines(i)
    align[4] <- 'format datatype=standard gap=- missing=? symbols="dfmpsu";'
    
    # change seqs back to sound segments
    if (grepl("prank", i)){

      seqs <- align[7:(length(align)-2)]   
      sep <- separate(data.frame(seqs = seqs),col = "seqs",sep =   "\t", into = c("song", "seqs")) 
      
      
      # replace song segments with bases
        sep$seqs <- gsub(pattern = "C", replacement = "f", x = sep$seqs) # trill to pyrimidine
        sep$seqs <- gsub(pattern = "T", replacement = "s", x = sep$seqs) # trill to pyrimidine
      sep$seqs <- gsub(pattern = "Y", replacement = "m", x = sep$seqs) # medium trill treated as ambiguous between fast and slow
      sep$seqs <- gsub(pattern = "A", replacement = "u", x = sep$seqs) # tone to purine
      sep$seqs <- gsub(pattern = "G", replacement = "d", x = sep$seqs) # tone to purine
      sep$seqs <- gsub(pattern = "R", replacement = "p", x = sep$seqs)
    
         align[7:(length(align)-2)] <- paste0(sep$song, "\t", sep$seqs)       
                   }
    write(align, i)
}


```


```{r revbayes loop, eval = FALSE,  echo = TRUE}

dat <- read.csv("./data/raw/segments_by_song_type.csv", stringsAsFactors = FALSE)

yrs <- read.csv("./data/raw/year_range_by_song_type.csv", stringsAsFactors = FALSE)

yrs$song.type.year <- paste(yrs$song.type, yrs$year, sep = "-")


alignment	<- c("optimal", "all.equal", "prank") # ER = equal rates

# use all fosils (e.g. SURA-2011, SURA-2012, )
use_all_fossils <- c("all", "early")

# include also fossils before 2008
use_old_fossils <-  c("old", "new")


# create taxa tsv files for revBayes
out <- lapply(unique(leks), function(x)
{
  
  X <- yrs[yrs$lek == x, ]
  X$taxon <- X$song.type.year
  
  X$max <- X$min <- max(X$year) - X$year
  
  # all fossils including before 2008
  all.old <- X <- X[order(X$song.type, X$year), ]
  
  write.table(all.old[, c("taxon", "min", "max")], file = paste0("./data/processed/revBayes/fossils/", x, "_taxa_all_old.tsv"),  sep = "\t", quote = FALSE, row.names = FALSE)

  # only first appearance of song type/fossil including before 2008   
  early.old <- X[!duplicated(X$song.type), ]
  
  write.table(early.old[, c("taxon", "min", "max")], file = paste0("./data/processed/revBayes/fossils/", x,  "_taxa_early_old.tsv"), sep = "\t", quote = FALSE, row.names = FALSE)

  
  Y <- X[X$year > 2007, ] 
  Y <- Y[order(Y$song.type, Y$year), ]
  
  # all fossils excluding before 2008
  all.new <- Y
  
    write.table(all.new[, c("taxon", "min", "max")], file = paste0("./data/processed/revBayes/fossils/", x,  "_taxa_all_new.tsv"), sep = "\t", quote = FALSE, row.names = FALSE)


  # only first appearance of song type/fossil including before 2008   
  early.new <- Y[!duplicated(Y$song.type), ]
  
  write.table(early.new[, c("taxon", "min", "max")], file = paste0("./data/processed/revBayes/fossils/", x,  "_taxa_early_new.tsv"), sep = "\t", quote = FALSE, row.names = FALSE)

  
} )

# make all possible combinations
grd <- expand.grid(lek = leks, alignment = alignment, use_old_fossils = use_old_fossils, use_all_fossils = use_all_fossils)

templ <- readLines("./source/template.Rev")

algs <- list.files(path = "./data/processed/nexus", pattern = "\\.nex$")

algs <- grep(pattern = "optimal", algs, value = TRUE)

grd <- grd[order(grd$lek), ]

# remove leks with output
current.output <- list.files(pattern = "log$|trees$", path = "./output/revbayes", recursive = TRUE)

done.leks <- unique(substr(current.output, start = 0, 3))

grd <- grd[!(grd$lek %in% done.leks & grd$alignment != "prank"), ]


out <- pblapply(1:nrow(grd), cl = 4, function(x){
  
  yrs.lek <- yrs[yrs$lek == grd$lek[x],]
  last.year.songs <- yrs.lek$song.type.year[yrs.lek$year == max(yrs.lek$year)]
  
  last.year.songs <- paste0(paste0('"', last.year.songs), '"')
  
  last.year.songs <- paste0("clade(", paste0(last.year.songs, collapse = ", "), ")")
  
 nx <- paste0("./data/processed/nexus/", grd$lek[x], "_", grd$alignment[x], "_", grd$use_all_fossils[x], "_", grd$use_old_fossils[x], "_alignment.nex")
  
  tsv <- paste0("./data/processed/revBayes/fossils/", grd$lek[x], "_taxa_", grd$use_all_fossils[x], "_", grd$use_old_fossils[x], ".tsv")
  
    templ <- readLines("./source/template.Rev")

    templ[1] <- gsub("aligment.name", nx, templ[1])
    templ[2] <- gsub("tsv.file", tsv, templ[2])
    templ[7] <- gsub("LAST.SONG.TYPES", last.year.songs, templ[7])
    
    
    fl.nm.rb <- paste0("./source/", grd$lek[x], "_", grd$use_all_fossils[x], "_", grd$use_old_fossils[x],".Rev")
     
    writeLines(templ, con = fl.nm.rb)

    # cll <- paste0("~/Downloads/revbayes/projects/cmake/rb ", fl.nm.rb)
    cll <- paste0("~/Documents/Marcelo/song_alignment/boost_1_71_0/revbayes/projects/cmake/rb ", fl.nm.rb) 
    
     system(cll,  show.output.on.console = FALSE)

    # copy ouput files to  /output/revbayes/
      new.output <- list.files(pattern = "log$|trees$", recursive = TRUE)
    
    copied.output <- list.files(pattern = "log$|trees$", path = "./output/revbayes/", recursive = TRUE)
    
    new.output <- new.output[!basename(new.output) %in% copied.output]
    
    if (length(new.output > 0))
    file.copy(from = output, to =file.path("./output/revbayes/", basename(output)))

})

  
```

