---
title: <center><font size="6"><b>MCMC diagnostics</b></font></center>
subtitle: <center><font size="4"><b><a href="https://github.com/maRce10/lbh_cultural_evolution">Long-billed hermit song cultural evolution<a></b></font></center>
author: <center><font size="4"><a href="http://marceloarayasalas.weebly.com/">Marcelo Araya-Salas PhD</a> & <a href="https://scholar.google.com/citations?user=0a8k9T8AAAAJ&hl=es&oi=ao"> Beatriz Willink PhD</a></font></center>
date: <center>`r format(Sys.Date(), "%d-%m-%Y")`</center>
output:
  html_document:
    code_folding: hide
    toc: no
    toc_depth: 3
    toc_float:
      collapsed: yes
      smooth_scroll: yes
fontsize: 12pt 
editor_options: 
  chunk_output_type: console
---

```{r clean session, eval = TRUE, echo = TRUE, message = FALSE, warning = FALSE}

#clean session
rm(list = ls())

# unload all non-based packages
out <- sapply(paste('package:', names(sessionInfo()$otherPkgs), sep = ""), function(x) try(detach(x, unload = FALSE, character.only = TRUE), silent = T))

## vector with package names
x <- c("pbapply", "parallel", "coda", "DT", "stringr")

aa <- lapply(x, function(y) {
  
  # check if installed, if not then install 
  if (!y %in% installed.packages()[,"Package"]) 
    install.packages(y) 

  # load package
  try(require(y, character.only = T), silent = T)
})

```

```{r functions and parameters, eval = TRUE}

knitr::opts_knit$set(root.dir = normalizePath(".."))

knitr::opts_chunk$set(dpi = 58, fig.width = 12, echo = TRUE) 

options(knitr.kable.NA = '')

# function to extract diagnostic stats
diag_stats <- function(x, thin = 1) {
  
  mods <- grep(x, model_runs, value = TRUE)
  
  out <- lapply(mods, function(y){
    
    temp <- read.table(file.path("output/revbayes", y), header = TRUE)
    chain <- mcmc(data = temp , start = 1, end = length(temp[,1]), thin = thin)

  return(chain)  
    })

  # make it a mcmc list object
  mh_list <- mcmc.list(out)
  
     #minimum effective sample size from combined traces
          min_ess <- min(effectiveSize(mh_list)[-1])
          
          #autocorrelations between draws in run 1
          autocorr_post <- diag(autocorr(mh_list[[1]])[2, , ])["Posterior"]
          autocorr_age_extant <- diag(autocorr(mh_list[[1]])[2, , ])["age_extant"] 
          autocorr_origin_time <- diag(autocorr(mh_list[[1]])[2, , ])["origin_time"]
          autocorr_diversification <- diag(autocorr(mh_list[[1]])[2, , ])["diversification"]
          autocorr_max <- max(abs(diag(autocorr(mh_list[[1]])[2, , ])[-1]))
          autocorr_bad <- paste0(names(which(diag(autocorr(mh_list[[1]])[2, , ])[-1] > 0.1)),
                                              collapse= ",")
        
          # Gelman- Rubin diagnostic of convergence between runs
          gr <- try(gelman.diag(mh_list,confidence = 0.95, transform=TRUE, 
                          autoburnin=FALSE, multivariate = TRUE), silent = TRUE)
        
          # catch error
          if (!is(gr, "try-error")){
          gr_post <- gr$psrf["Posterior", 1]
          gr_age_extant <- gr$psrf["age_extant", 1]
          gr_origin_time <- gr$psrf["origin_time",1]
          gr_diversification <- gr$psrf["diversification",1]
          gr_max <- max(gr$psrf[-1,1])
          gr_bad <- paste0(names(which(gr$psrf[-1,1] > 1.05)), collapse = ",")
          gr_mpsrf <- gr$mpsrf
          } else {
          gr_post <- NA
          gr_age_extant <- NA
          gr_origin_time <- NA
          gr_diversification <- NA
          gr_max <- NA
          gr_bad <- NA
          gr_mpsrf <- NA            
          }
        
          # date it was run
          updated <- substr(x = file.info(file.path("output/revbayes", mods[1]))$mtime, 0 , 10)
          
          # put results in a data frame
    out_df <- data.frame(model = x, min_ess, autocorr_post, autocorr_age_extant, autocorr_origin_time, autocorr_diversification, autocorr_max, autocorr_bad, gr_post, gr_age_extant, gr_origin_time, gr_diversification, gr_max, gr_bad, gr_mpsrf, updated)
}

# function for MCMCglmm diagnostics
# plot diagonostic stuff for mcmcglmmm models
# X == mcmc.list
plot_traces <- function(X, clms = 4, cex = 1, cols = adjustcolor(c("yellow","blue"), alpha.f = 0.6)) {

  # reset par when done
  opar <- par()
  on.exit(par(opar))
  
  # trace and autocorrelation  
  if (clms > 1) par(mfrow = c(1, clms))
  for(y in colnames(X[[1]])){

    Z <- lapply(X, function(x) x[, y, drop = FALSE])
    
    traceplot(Z, col = cols, cex.lab=cex, cex.axis=cex, main = "")
    
    title(y, cex.main = cex + 0.5)
    
    if (grepl("age_extant", y))
    autocorr.plot2(Z[[1]], col = "gray", lwd = 4, ask = FALSE, auto.layout = FALSE, cex.axis = cex, cex.lab = cex, cex = cex + 0.5, main = y)
    } 
}

# modified internal from coda
autocorr.plot2 <- function(x, lag.max, auto.layout = TRUE, ask, main, cex = 1, ...) {
  if (missing(ask)) {
    ask <- if (is.R()) {
      dev.interactive()
    }
    else {
      interactive()
    }
  }
  oldpar <- NULL
  on.exit(par(oldpar))
  if (auto.layout) 
    oldpar <- par(mfrow = set.mfrow(Nchains = nchain(x), 
      Nparms = nvar(x)))
  if (!is.mcmc.list(x)) 
    x <- mcmc.list(as.mcmc(x))
  for (i in 1:nchain(x)) {
    xacf <- if (missing(lag.max)) 
      acf(as.ts.mcmc2(x[[i]]), plot = FALSE)
    else acf(as.ts.mcmc2(x[[i]]), lag.max = lag.max, plot = FALSE)
    for (j in 1:nvar(x)) {
      plot(xacf$lag[, j, j], xacf$acf[, j, j], type = "h", 
        ylab = "Autocorrelation", xlab = "Lag", ylim = c(-1, 
          1), ...)
      title(main, cex.main = cex)
      if (i == 1 && j == 1) 
        oldpar <- c(oldpar, par(ask = ask))
    }
  }
  invisible(x)
}

# modified internal from coda
as.ts.mcmc2 <- function (x, ...) 
{
  x <- as.mcmc(x)
  y <- ts(x, start = start(x), end = end(x), deltat = thin(x))
  attr(y, "mcpar") <- NULL
  return(y)
}

```
   
```{r re-calculate diagnostic stats, eval = FALSE}

## RUN TO UPDATE OUTPUT ###

# get model run log file names
model_runs <- list.files("output/revbayes", pattern = "run_([[:digit:]]+)\\.log$")

# get base model name (removing run_#) 
base_models <- sapply(strsplit(model_runs, "_run", fixed = TRUE), "[", 1)

# extract diagnostic stats for each model 
# wrapped in try() to catch errors
runs <- pblapply(unique(base_models), cl = parallel::detectCores() - 1, function(x) try(diag_stats(x, thin = if (substr(x, 0, 3) %in% c("CCE", "SUR")) 2 else 1), silent = TRUE))

# remove errors
runs <- runs[sapply(runs, is.data.frame)]

# put in a single data frame
model_diags <- do.call(rbind, runs)

# save
write.csv(model_diags, "output/diagnostics_revbayes_output.csv", row.names = FALSE)

```
  
## Diagnostics: Gelman-Rubin, ESS, and autocorrelation

The table below can be read like this:
`read.csv("https://raw.githubusercontent.com/maRce10/lbh_cultural_evolution/master/output/diagnostics_revbayes_output.csv")`


```{r, eval = TRUE, echo = TRUE}

model_diags <- read.csv("output/diagnostics_revbayes_output.csv", stringsAsFactors = FALSE)

# get lek name
model_diags$lek <- sapply(strsplit(model_diags$model, "_", fixed = TRUE), "[", 1)

# substitution model
model_diags$subs <- sapply(strsplit(model_diags$model, "_", fixed = TRUE), "[", 2)

# period
model_diags$period <- sapply(strsplit(model_diags$model, "_", fixed = TRUE), "[", 3)

# and which fossils were used
model_diags$fossils <- sapply(strsplit(model_diags$model, "_", fixed = TRUE), "[", 4)

# order columns
model_diags <- model_diags[, c(c("model", "lek", "subs", "period", "fossils", "autocorr_bad", "gr_bad")   , names(which(sapply(model_diags, is.numeric))), "updated")]

# round
model_diags[, sapply(model_diags, is.numeric)] <- round(model_diags[, sapply(model_diags, is.numeric)], 4)

#count "bad" branch rates per row
brc <- paste0("branch_rates_count:",(str_count(pattern = "branch_rates", model_diags$autocorr_bad)))

model_diags$autocorr_bad <- gsub("branch_rates\\.([[:digit:]]+)\\.|\\,branch_rates\\.([[:digit:]]+)\\.","", model_diags$autocorr_bad)

model_diags$autocorr_bad <- paste(model_diags$autocorr_bad, brc)

brc2 <- paste0("branch_rates_count:",(str_count(pattern = "branch_rates", model_diags$gr_bad)))

model_diags$gr_bad <- gsub("branch_rates\\.([[:digit:]]+)\\.|\\,branch_rates\\.([[:digit:]]+)\\.","", model_diags$gr_bad)

model_diags$gr_bad <- paste(model_diags$gr_bad, brc)


# add link to plots
plts <- list.files(path = "./output/MCMC_diagnostic_plots", pattern = "\\.jpg$")
  
jpgs <- lapply(model_diags$model, function(x)
grep(paste(gsub("\\_([[:digit:]]+)", "", x), collapse = "|"), plts, value = TRUE))

model_diags$diag_plots <- sapply(model_diags$model, function(x)

paste(paste0('<a href=\"https://raw.githubusercontent.com/maRce10/lbh_cultural_evolution/master/output/MCMC_diagnostic_plots/', grep(paste(paste0(gsub("\\_([[:digit:]]+)", "", x), "_0"), collapse = "|"), plts, value = TRUE),'">', grep(paste(paste0(gsub("\\_([[:digit:]]+)", "", x), "_0"), collapse = "|"), plts, value = TRUE), '</a>'), collapse = " ")
)


# print dynamic table
datatable(model_diags, editable = list(
  target = 'row'
), rownames = FALSE, style = "bootstrap",  filter = 'top', options = list(
  pageLength = 100, autoWidth = TRUE, dom = 'ft'
), autoHideNavigation = TRUE, escape = FALSE)

```

```{r plot traces to files, eval = FALSE, fig.height = 3.3, fig.width = 30, warning = FALSE, message = FALSE, dpi = 30}

## RUN TO UPDATE OUTPUT ###

# these plots will be linked to in the table of this Rmarkdown's output

# get model run log file names
model_runs <- list.files("output/revbayes", pattern = "run_([[:digit:]]+)\\.log$")

# get base model name (removing run_#) 
base_models <- sapply(strsplit(model_runs, "_run", fixed = TRUE), "[", 1)

# loop to make plots
out <- pblapply(base_models, function(x){
  
  # info on base model    
  # print(gsub("_([[:digit:]]+)", "", x))
    
  # extract run names
  mods <- grep(x, model_runs, value = TRUE)
  
  # loop over each pair of runs
  out <- lapply(mods, function(z){
    
    temp <- read.table(file.path("output/revbayes", z), header = TRUE)
    
    temp <- temp[,c("Posterior", "Likelihood", "Prior", "age_extant", "origin_time", "num_samp_anc", "speciation_rate", "extinction_rate", "diversification", "turnover", "psi", "er.1.", "er.2.", "er.3.", "er.4.", "er.5.", "er.6.", "er.7.", "er.8.", "er.9.", "er.10.", "er.11.","er.12.", "er.13.", "er.14.", "er.15.", "sf.1.", "sf.2.", "sf.3.", "sf.4.", "sf.5.", "sf.6.","alpha_song", "rates_song.1.", "rates_song.2.", "rates_song.3.", "rates_song.4.", grep("branch_rates", colnames(temp), value = TRUE))]
    
    chain <- mcmc(data = temp, start = 1, end = length(temp[,1]), thin = if (substr(x, 0, 3) %in% c("CCE", "SUR")) 2 else 1)

  return(chain)  
    }
  )
  
  # create if it doesn't exist
  if (!file.exists(file.path("./output/MCMC_diagnostic_plots", paste0(gsub("_([[:digit:]]+)", "", x), "_01.jpg")))){
    # plot 
  jpeg(filename = file.path("./output/MCMC_diagnostic_plots", paste0(gsub("_([[:digit:]]+)", "", x), "_%02d.jpg")), width = 1500, height = 1200, pointsize = 6)  
  
  ncol <- ncol(out[[1]])
  
  par(mfrow = c(10, 10))
  
  out2 <- try(plot_traces(X = out, clms = 1, cex = 2.5), silent = TRUE)
  
    # close device
    dev.off()
    }
  }
  )

```
                                                          
---

<font size="4">R session information</font>

```{r session info, echo=F}

sessionInfo()

```
